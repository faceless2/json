package com.bfo.json;

import java.io.*;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.channels.ReadableByteChannel;

/**
 * A processor interface for Json stream events, such as those generated by a file
 * parser or by traversing an existing Json object to write it out.
 */
public interface JsonStream {

    /**
     * Return true if this JsonStream would prefer Map keys to be sorted.
     * Only event sources where the data is in memory (eg the {@link Json} object
     * are expected to be able to comply with this.
     * The default method implementation returns false.
     */
    public default boolean isSorted() {
        return false;
    }

    /**
     * Process an event. Return true if the stream has completed. Any events submitted after this will cause an error
     * @return true if the stream has completed
     */
    public boolean event(Event event) throws IOException;

    /**
     * Return a simple wrapper around the specified Stream which will log events to System.out
     * @param stream the stream to wrap, or null just to print them with no action
     */
    public static JsonStream getDebugger(final JsonStream stream) {
        return new JsonStream() {
            public boolean event(Event event) throws IOException {
//                System.out.println(event);
                return stream != null && stream.event(event);
            }
        };
    }

    /**
     * The Events that are processed by a {@link JsonStream}
     */
    public static final class Event {

        public static final int  TYPE_MAP_START = 1;
        public static final int  TYPE_LIST_START = 2;
        public static final int  TYPE_MAP_END = 3;
        public static final int  TYPE_LIST_END = 4;
        public static final int  TYPE_BUFFER_START = 5;
        public static final int  TYPE_BUFFER_END = 6;
        public static final int  TYPE_STRING_START = 7;
        public static final int  TYPE_STRING_END = 8;
        public static final int  TYPE_PRIMITIVE = 9;
        public static final int  TYPE_STRING_DATA = 10;
        public static final int  TYPE_BUFFER_DATA = 11;
        public static final int  TYPE_TAG = 12;
        public static final int  TYPE_SIMPLE = 13;

        private static final Event STARTMAP = new Event(TYPE_MAP_START, null, -1);
        private static final Event STARTLIST = new Event(TYPE_LIST_START, null, -1);
        private static final Event STARTSTRING = new Event(TYPE_STRING_START, null, -1);
        private static final Event STARTBUFFER = new Event(TYPE_BUFFER_START, null, -1);
        private static final Event ENDMAP = new Event(TYPE_MAP_END, null, 0);
        private static final Event ENDLIST = new Event(TYPE_LIST_END, null, 0);
        private static final Event ENDSTRING = new Event(TYPE_STRING_END, null, 0);
        private static final Event ENDBUFFER = new Event(TYPE_BUFFER_END, null, 0);
        private static final Event TRUE = new Event(TYPE_PRIMITIVE, Boolean.TRUE, 0);
        private static final Event FALSE = new Event(TYPE_PRIMITIVE, Boolean.FALSE, 0);
        private static final Event NULL = new Event(TYPE_PRIMITIVE, Json.NULL, 0);
        private static final Event UNDEFINED = new Event(TYPE_PRIMITIVE, Json.UNDEFINED, 0);

        /**
         * Create a new {@link TYPE_MAP_START} event
         * @param size the number of [key,value] pairs in the map, or -1 if unknown
         */
        public static Event startMap(int size) {
            return size < 0 ? STARTMAP : new Event(TYPE_MAP_START, null, size);
        }

        /**
         * Create a new {@link TYPE_MAP_START} event
         * @param size the number of objects in the list, or -1 if unknown
         */
        public static Event startList(int size) {
            return size < 0 ? STARTLIST : new Event(TYPE_LIST_START, null, size);
        }

        /**
         * Create a new {@link TYPE_STRING_START} event
         * @param sizeInBytes the size of the String in bytes, or a value of -1 for indefinite
         */
        public static Event startString(long sizeInBytes) {
            return sizeInBytes < 0 ? STARTSTRING : new Event(TYPE_STRING_START, null, sizeInBytes);
        }

        /**
         * Create a new {@link TYPE_BUFFER_START} event
         * @param size the size of the Buffer in bytes, or a value of -1 for indefinite
         */
        public static Event startBuffer(long size) {
            return size < 0 ? STARTBUFFER : new Event(TYPE_BUFFER_START, null, size);
        }

        /**
         * Get an {@link TYPE_MAP_END} event
         */
        public static Event endMap() {
            return ENDMAP;
        }

        /**
         * Get an {@link TYPE_LIST_END} event
         */
        public static Event endList() {
            return ENDLIST;
        }

        /**
         * Get an {@link TYPE_STRING_END} event
         */
        public static Event endString() {
            return ENDSTRING;
        }

        /**
         * Get an {@link TYPE_BUFFER_END} event
         */
        public static Event endBuffer() {
            return ENDBUFFER;
        }

        /**
         * Get an {@link TYPE_PRIMITIVE} event with the specified boolean value
         */
        public static Event booleanValue(boolean b) {
            return b ? TRUE : FALSE;
        }

        /**
         * Get an {@link TYPE_PRIMITIVE} event with a null value
         */
        public static Event nullValue() {
            return NULL;
        }

        /**
         * Get an {@link TYPE_PRIMITIVE} event with an "undefined" value
         */
        public static Event undefinedValue() {
            return UNDEFINED;
        }

        /**
         * Get an {@link TYPE_PRIMITIVE} event with the specified number value
         */
        public static Event numberValue(Number number) {
            return new Event(TYPE_PRIMITIVE, number, 0);
        }

        /**
         * Get an {@link TYPE_PRIMITIVE} event with the specified string value.
         * This can be used as an alternative to {@link #startString}, {@link #stringData}
         * and {@link #endString} events for simple Strings.
         * Note the parameter is <b>not copied</b> and the underlying array may be reused,
         * so the event should be processed immediately or {@link #copy} called.
         * @param seq the sequence
         * @param sizeInBytes the UTF-8 byte length of the CharSequence if known, or -1 if undefined
         */
        public static Event stringValue(CharSequence seq, int sizeInBytes) {
            return new Event(TYPE_PRIMITIVE, seq, sizeInBytes);
        }

        /**
         * Get an {@link TYPE_STRING_DATA} event with the specified {@link CharSequence}.
         * Zero or more events of this type are issued between {@link #startString}
         * and {@link #endString} events
         * Note the parameter is <b>not copied</b> and the underlying array may be reused,
         * so the event should be processed immediately or {@link #copy} called.
         * @param data the character data
         */
        public static Event stringData(CharSequence data) {
            return new Event(TYPE_STRING_DATA, data, 0);
        }

        /**
         * Get an {@link TYPE_STRING_DATA} event with the specified {@link Readable}
         * Zero or more events of this type are issued between {@link #startString}
         * and {@link #endString} events
         * Note the parameter is <b>not copied</b> and the underlying array may be reused,
         * so the event should be processed immediately.
         * @param data the character data stream
         */
        public static Event stringData(Readable data) {
            return new Event(TYPE_STRING_DATA, data, 0);
        }

        /**
         * Get an {@link TYPE_BUFFER_DATA} event with the specified {@Link ByteBuffer}.
         * Zero or more events of this type are issued between {@link #startBuffer}
         * and {@link #endBuffer} events
         * Note the parameter is <b>not copied</b> and the underlying array may be reused,
         * so the event should be processed immediately or {@link #copy} called.
         * @param data the byte data
         */
        public static Event bufferData(ByteBuffer data) {
            return new Event(TYPE_BUFFER_DATA, data, 0);
        }

        /**
         * Get an {@link TYPE_BUFFER_DATA} event with the specified {@link ReadableByteChannel}.
         * Zero or more events of this type are issued between {@link #startBuffer}
         * and {@link #endBuffer} events
         * Note the parameter is <b>not copied</b> and the underlying array may be reused,
         * so the event should be processed immediately.
         * @param data the byte data stream
         */
        public static Event bufferData(ReadableByteChannel data) {
            return new Event(TYPE_BUFFER_DATA, data, 0);
        }

        /**
         * Specify a tag to apply to to the next map, list, string, buffer or primitive value
         * @param tag the tag number, which must be positive
         */
        public static Event tagNext(long tag) {
            if (tag < 0) {
                throw new IllegalArgumentException("Tag is negative");
            }
            return new Event(TYPE_TAG, Long.valueOf(tag), 0);
        }

        /**
         * Get a {@link TYPE_SIMPLE} event with the specified value. "simple" datatypes are
         * named after the term in CBOR, but these have no corresponding concept Json.
         * @param tag the value
         */
        public static Event simple(int value) {
            return new Event(TYPE_SIMPLE, Integer.valueOf(value), 0);
        }

        /**
         * Return a copy of the this event which is suitable for storing.
         */
        Event copy() {
            if (data instanceof CharSequence && !(data instanceof String)) {
                return new Event(type, data.toString(), size);
            } else if (data instanceof ByteBuffer) {
                ByteBuffer buf = (ByteBuffer)data;
                byte[] tmp = new byte[buf.remaining()];
                buf.get(tmp).position(buf.position() - tmp.length);
                return new Event(type, ByteBuffer.wrap(tmp), size);
            } else {
                return this;
            }
        }

        /**
         * Return the type, eg {@link #TYPE_MAP_END}
         */
        public int type() {
            return type;
        }

        /**
         * Return the size specified in the event, or 0 if the event has no size
         */
        public long size() {
            return size;
        }

        /**
         * For {@link #TYPE_TAG} events, return the tag value, or 0 for other events
         */
        public long tagValue() {
            return type == TYPE_TAG ? ((Long)data).longValue() : 0;
        }

        /**
         * Return true for {@link #TYPE_PRIMITIVE} events with a null value, otherwise false
         */
        public boolean isNull() {
            return data == Json.NULL;
        }

        /**
         * Return true for {@link #TYPE_PRIMITIVE} events with an undefined value, otherwise false
         */
        public boolean isUndefined() {
            return data == Json.UNDEFINED;
        }

        /**
         * Return the value for {@link #TYPE_PRIMITIVE} events representing booleans, otherwise null
         */
        public Boolean booleanValue() {
            return data instanceof Boolean ? (Boolean)data : null;
        }

        /**
         * Return the value for {@link #TYPE_PRIMITIVE} events representing numbers or {@link #TYPE_SIMPLE}, otherwise null
         */
        public Number numberValue() {
            return data instanceof Number ? (Number)data : null;
        }

        /**
         * Return the value for {@link #TYPE_PRIMITIVE} or {@link #TYPE_STRING_DATA} events created with a CharSequence, otherwise null
         */
        public CharSequence stringValue() {
            return data instanceof CharSequence ? (CharSequence)data : null;
        }

        /**
         * Return the value for {@link #TYPE_PRIMITIVE} or {@link #TYPE_STRING_DATA} events created with a CharSequence, otherwise null
         */
        public Readable readableValue() {
            return data instanceof Readable ? (Readable)data : null;
        }

        /**
         * Return the value for {@link #TYPE_BUFFER_DATA} events created with a ByteBuffer, otherwise null
         */
        public ByteBuffer bufferValue() {
            return data instanceof ByteBuffer ? (ByteBuffer)data : null;
        }

        /**
         * Return the value for {@link #TYPE_BUFFER_DATA} events created with a ReadableByteChannel, otherwise null
         */
        public ReadableByteChannel readableByteChannelValue() {
            return data instanceof ReadableByteChannel ? (ReadableByteChannel)data : null;
        }

        /**
         * Return the value for {@link #TYPE_PRIMITIVE} events
         */
        public Object value() {
            return data;
        }

        private final int type;
        private final long size;
        private final Object data;

        private Event(int type, Object data, long size) {
            this.type = type;
            this.data = data;
            this.size = size;
        }

        public String toString() {
            switch(type) {
                case TYPE_MAP_START:         return "{startMap" + (size < 0 ? "" : " size="+size) + "}";
                case TYPE_LIST_START:        return "{startList" + (size < 0 ? "" : " size="+size) + "}";
                case TYPE_STRING_START:      return "{startString" + (size < 0 ? "" : " size="+size) + "}";
                case TYPE_BUFFER_START:      return "{startBuffer" + (size < 0 ? "" : " size="+size) + "}";
                case TYPE_MAP_END:           return "{endMap}";
                case TYPE_LIST_END:          return "{endList}";
                case TYPE_STRING_END:        return "{endString}";
                case TYPE_BUFFER_END:        return "{endBuffer}";
                case TYPE_PRIMITIVE:        return this == TRUE ? "{true}" : this == FALSE ? "{false}" : this == NULL ? "{null}" : this == UNDEFINED ? "{undefined}" : data instanceof Number ? "{number " + data + "}" : "{string " + Json.esc((CharSequence)data, null) + "}";
//                case TYPE_STRING_DATA:       return "{string-data" + (data instanceof Readable ? " readable" : " string " + Json.esc((CharSequence)data, null)) + "}";
                case TYPE_STRING_DATA:       return "{string-data" + (data instanceof Readable ? " readable" : " string") + "}";
                case TYPE_BUFFER_DATA:       return "{buffer-data" + (data instanceof ReadableByteChannel ? " readable" : " bytebuffer") + "}";
                case TYPE_TAG:              return "{tag " + data + "}";
                case TYPE_SIMPLE:           return "{simple " + data + "}";
                default:                    return "{UNKNOWN " + type + "}";        // Can't happen
            }
        }

    }
}
